/*********************************************************************************
 *  Optimized Arduino Code for a Multi-Sensor Monitor (Corrected Version)
 *
 *  Date: 2025-09-15
 *
 *  Correction Summary (Thanks to user feedback):
 *  - Removed the dependency on AHTxx.h library for DHT20.
 *  - Now uses the official Adafruit DHT.h library, which natively supports
 *    both DHT11 (single-wire) and DHT20 (I2C).
 *  - This simplifies the code and resolves the "'AHTxx' does not name a type" error.
 *
 *********************************************************************************/

// --- LIBRARIES ---
#include <U8g2lib.h>
#include <Wire.h>
#include <MsTimer2.h>
#include "LIS3DHTR.h"
#include "DHT.h" // Unified library for both DHT11 and DHT20

// --- SENSOR SELECTION MACROS ---
// Choose your temperature/humidity sensor. Options: SENSOR_DHT11, SENSOR_DHT20
#define TEMP_HUMID_SENSOR_TYPE SENSOR_DHT20

// Choose your pressure sensor. Options: SENSOR_BME280, SENSOR_SPL07
#define PRESSURE_SENSOR_TYPE SENSOR_SPL07

// --- UNCONDITIONAL INCLUDES FOR PRESSURE SENSORS ---
// We include both headers unconditionally to ensure the IDE links the correct files.
#include "Seeed_BMP280.h"
#include "SPL07-003.h"

// --- CONSTANTS AND ENUMS ---
#define SENSOR_DHT11 1
#define SENSOR_DHT20 2
#define SENSOR_BME280 3
#define SENSOR_SPL07 4

// Board version selection for different pinouts
#define BOARD_VERSION 2

// Button press detection constants
const int LONG_PRESS_CLICKS = 100; // Clicks (10ms each) to detect a long press (100 * 10ms = 1s)

// Sound sensor moving average filter settings
const int SOUND_QUEUE_LEN = 10;

// Enums for program modes for better readability
enum ProgramMode {
  MODE_LIGHT = 1,
  MODE_SOUND = 2,
  MODE_TEMP_HUMID = 3,
  MODE_PRESSURE = 4,
  MODE_ACCEL = 5
};

// --- BITMAPS (Stored in PROGMEM to save RAM) ---
// (Bitmap data is kept the same as the original code)
const unsigned char sound_bmp[] U8X8_PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x3e, 0x00, 0x80, 0x3f, 0x0c, 0xc0, 0x3b, 0x0c, 0xfe, 0xb8, 0x0d, 0x7f, 0xb8, 0x0d, 0x03, 0xb8, 0x0d, 0x03, 0xb8, 0x0d, 0x03, 0xb8, 0x0d, 0x03, 0xb8, 0x0d, 0x03, 0xb8, 0x0d, 0xff, 0xb8, 0x0d, 0xc0, 0x39, 0x0c, 0x80, 0x3f, 0x0c, 0x00, 0x3e, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00};
const unsigned char temp_bmp[] U8X8_PROGMEM = {0x00, 0x06, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x09, 0x00, 0x80, 0x19, 0x00, 0x80, 0x19, 0x00, 0xc0, 0x39, 0x00, 0xc0, 0x39, 0x00, 0xc0, 0x39, 0x00, 0xc0, 0x39, 0x00, 0xc0, 0x3f, 0x00, 0x80, 0x1f, 0x00, 0x80, 0x1f, 0x00, 0x00, 0x06, 0x00};
const unsigned char hum_bmp[] U8X8_PROGMEM= {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0x00,0x80,0x10,0x00,0x00,0x00,0x00,0x40,0x20,0x00,0x20,0x40,0x00,0x20,0x40,0x00,0x10,0x80,0x00,0x10,0x80,0x00,0x08,0x00,0x01,0x08,0x00,0x01,0x08,0x00,0x01,0x08,0x00,0x01,0x08,0x00,0x01,0x08,0x00,0x01,0x10,0x80,0x00,0x00,0x00,0x00,0x40,0x20,0x00,0x80,0x10,0x00};
const unsigned char pressure_bmp1[] U8X8_PROGMEM= {0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x80,0x96,0x01,0x80,0x1f,0x03,0x00,0x0f,0x06,0x18,0x06,0x04,0x1c,0x04,0x04,0x06,0x00,0x06,0xc6,0xff,0x03,0xc6,0xff,0x01,0x04,0x00,0x00,0xfc,0xff,0x03,0xf8,0xff,0x03,0x00,0x00,0x00,0xfe,0xff,0x07,0xfe,0xff,0x07,0x00,0x00,0x00};
const unsigned char pressure_bmp[] U8X8_PROGMEM= {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0xc8,0xc4,0x01,0x00,0xf8,0x87,0x07,0x00,0xf8,0x87,0x07,0x60,0xf0,0x03,0x04,0x60,0xf0,0x03,0x04,0xf0,0xc0,0x00,0x04,0xf0,0xc0,0x00,0x04,0x18,0x00,0x00,0x06,0x18,0x00,0x00,0x06,0x08,0xfc,0xff,0x03,0x08,0xfc,0xff,0x03,0x18,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0xf0,0xff,0xff,0x03,0xf0,0xff,0xff,0x03,0xe0,0xff,0xff,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xff,0xff,0x1f,0xfe,0xff,0xff,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const unsigned char light_tmp[] U8X8_PROGMEM = {0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x80, 0xc1, 0x60, 0x00, 0x80, 0xc3, 0x70, 0x00, 0x00, 0xc3, 0x30, 0x00, 0x00, 0xc7, 0x38, 0x00, 0x00, 0x06, 0x18, 0x00, 0x0c, 0xf0, 0x03, 0x0c, 0x3c, 0xfc, 0x0f, 0x0f, 0x78, 0x1e, 0x9e, 0x07, 0x60, 0x07, 0xb8, 0x01, 0x00, 0x03, 0x30, 0x00, 0x80, 0x03, 0x70, 0x00, 0x80, 0x01, 0x60, 0x00, 0xbf, 0x01, 0x60, 0x3f, 0xbf, 0x01, 0x60, 0x3f, 0x80, 0x01, 0x60, 0x00, 0x80, 0x03, 0x70, 0x00, 0x00, 0x03, 0x30, 0x00, 0x60, 0x07, 0xb8, 0x01, 0x78, 0x1e, 0x9e, 0x07, 0x3c, 0xfc, 0x0f, 0x0f, 0x0c, 0xf0, 0x03, 0x0c, 0x00, 0x06, 0x18, 0x00, 0x00, 0xc7, 0x38, 0x00, 0x00, 0xc3, 0x30, 0x00, 0x80, 0xc3, 0x70, 0x00, 0x80, 0xc1, 0x60, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00};
const unsigned char sound_bmp1[] U8X8_PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x60, 0x00, 0x00, 0x70, 0xc0, 0x00, 0x00, 0x48, 0x80, 0x01, 0x00, 0x4c, 0x18, 0x03, 0x00, 0x46, 0x30, 0x02, 0x00, 0x43, 0x60, 0x04, 0x80, 0x41, 0x43, 0x04, 0xfc, 0x40, 0x84, 0x08, 0x46, 0x40, 0x8c, 0x08, 0x46, 0x40, 0x88, 0x08, 0x46, 0x40, 0x10, 0x09, 0x06, 0x40, 0x10, 0x09, 0x06, 0x40, 0x10, 0x19, 0x06, 0x40, 0x10, 0x09, 0x06, 0x40, 0x10, 0x09, 0x46, 0x40, 0x18, 0x09, 0x46, 0x40, 0x88, 0x08, 0x46, 0x40, 0x8c, 0x08, 0xfc, 0x40, 0x86, 0x0c, 0x80, 0x41, 0x43, 0x04, 0x00, 0x43, 0x20, 0x04, 0x00, 0x42, 0x30, 0x02, 0x00, 0x44, 0x0c, 0x03, 0x00, 0x48, 0x80, 0x01, 0x00, 0x50, 0xc0, 0x00, 0x00, 0x60, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
const unsigned char acel_bmp[] U8X8_PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x07, 0x00, 0x00, 0x07, 0x1c, 0x00, 0x80, 0x01, 0x60, 0x00, 0x60, 0x00, 0x80, 0x00, 0x30, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x02, 0x08, 0x00, 0x00, 0x04, 0x0c, 0x00, 0x00, 0x04, 0x04, 0x20, 0x01, 0x08, 0x04, 0x10, 0x02, 0x08, 0x02, 0xf8, 0x03, 0x08, 0x02, 0x0c, 0x0e, 0x10, 0x02, 0x0a, 0x10, 0x10, 0x02, 0x0a, 0x10, 0x10, 0x02, 0x02, 0x0a, 0x10, 0x02, 0x18, 0x06, 0x18, 0x06, 0x10, 0x02, 0x08, 0x04, 0x20, 0x01, 0x08, 0x04, 0xc0, 0x00, 0x0c, 0x08, 0x00, 0x00, 0x04, 0x18, 0x00, 0x00, 0x02, 0x30, 0x00, 0x00, 0x03, 0x60, 0x00, 0x80, 0x01, 0xc0, 0x00, 0xc0, 0x00, 0x00, 0x03, 0x30, 0x00, 0x00, 0xfc, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
const unsigned char temp_bmp1[] U8X8_PROGMEM = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0xfc, 0x01, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x07, 0xfe, 0xff, 0xff, 0x1f, 0x8f, 0xff, 0xff, 0x3f, 0x0f, 0x00, 0x00, 0x3e, 0x0f, 0x00, 0x00, 0x3e, 0x8f, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0x1f, 0xfe, 0xff, 0xff, 0x07, 0xfc, 0x01, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// --- PIN DEFINITIONS based on BOARD_VERSION ---
#if BOARD_VERSION == 1
  const byte ledPin = 5;
  const byte buzzerPin = 6;
  const byte buttonPin = 2;
  const byte rotaryPin = A1;
  const byte lightPin = A2;
  const byte soundPin = A0;
  const byte dhtPin = 4;
#elif BOARD_VERSION == 2
  const byte ledPin = 4;
  const byte buzzerPin = 5;
  const byte buttonPin = 6;
  const byte rotaryPin = A0;
  const byte lightPin = A6;
  const byte soundPin = A2;
  const byte dhtPin = 3;
#endif

// --- HARDWARE OBJECTS ---
U8G2_SSD1306_128X64_NONAME_1_HW_I2C u8g2(U8G2_R2, /* reset=*/U8X8_PIN_NONE);
LIS3DHTR<TwoWire> accelerometer;

// --- CORRECTED SENSOR DECLARATION ---
// Conditionally define DHTTYPE based on the sensor selection
#if (TEMP_HUMID_SENSOR_TYPE == SENSOR_DHT11)
  #define DHTTYPE DHT11
#elif (TEMP_HUMID_SENSOR_TYPE == SENSOR_DHT20)
  #define DHTTYPE DHT20
#endif
// Create a single DHT object. The library handles I2C vs single-wire internally.
// For I2C sensors like DHT20, the 'dhtPin' argument is ignored by the library.
DHT dht(dhtPin, DHTTYPE);


// Conditionally declare pressure sensor object
#if (PRESSURE_SENSOR_TYPE == SENSOR_BME280)
  BMP280 bmp280;
#elif (PRESSURE_SENSOR_TYPE == SENSOR_SPL07)
  SPL07_003 spl;
#endif

// --- GLOBAL STATE VARIABLES ---
ProgramMode currentMode = MODE_LIGHT;
bool isInMenuMode = false;

// Variables for accelerometer ball position
int ball_x = 80;
int ball_y = 35;

// Sound data queue for filtering
int soundQueue[SOUND_QUEUE_LEN] = {0};

// --- VOLATILE VARIABLES FOR ISR ---
volatile int pressCounter = 0;
volatile bool ledBlinkEnable = false;

// --- FUNCTION PROTOTYPES ---
void display_light();
void display_sound();
void display_temp_humid();
void display_pressure();
void display_accel();
void display_menu();
void handle_button();
int filter_sound(int newData, int queue[], int len);

// --- INTERRUPT SERVICE ROUTINE (ISR) ---
void checker_ISR() {
  static int ledBlinkCounter = 0;
  if (ledBlinkEnable) {
    digitalWrite(ledPin, HIGH);
    ledBlinkCounter++;
    if (ledBlinkCounter > 10) {
      ledBlinkCounter = 0;
      ledBlinkEnable = false;
      digitalWrite(ledPin, LOW);
    }
  }
  if (digitalRead(buttonPin) == HIGH) {
    pressCounter++;
  } else {
    pressCounter = 0;
  }
}

// --- SETUP ---
void setup() {
  Serial.begin(115200);
  Wire.begin();

  // --- Initialize Pins ---
  pinMode(ledPin, OUTPUT);
  pinMode(buzzerPin, OUTPUT);
  pinMode(buttonPin, INPUT);
  pinMode(rotaryPin, INPUT);
  pinMode(lightPin, INPUT);
  pinMode(soundPin, INPUT);
  digitalWrite(buzzerPin, LOW);

  // --- Initialize Display ---
  u8g2.begin();

  // --- Initialize Sensors ---
  // Temperature & Humidity Sensor
  dht.begin();
  Serial.print("DHT Sensor Type: ");
  Serial.println(DHTTYPE);

  // Pressure Sensor
#if (PRESSURE_SENSOR_TYPE == SENSOR_BME280)
  if (!bmp280.init()) {
    Serial.println("BME280 init error!");
  } else {
    Serial.println("BME280 sensor initialized.");
  }
#elif (PRESSURE_SENSOR_TYPE == SENSOR_SPL07)
  if (!spl.begin(SPL07_ADDR_DEF, &Wire)) {
    Serial.println("SPL07-003 init error!");
  } else {
    Serial.println("SPL07-003 sensor initialized.");
    spl.setPressureConfig(SPL07_4HZ, SPL07_32SAMPLES);
    spl.setTemperatureConfig(SPL07_4HZ, SPL07_1SAMPLE);
    spl.setMode(SPL07_CONT_PRES_TEMP);
  }
#endif

  // Accelerometer
  accelerometer.begin(Wire, LIS3DHTR_ADDRESS_UPDATED);
  delay(100);
  if (!accelerometer) {
    Serial.println("LIS3DHTR didn't connect.");
  } else {
    Serial.println("LIS3DHTR sensor initialized.");
    accelerometer.setOutputDataRate(LIS3DHTR_DATARATE_50HZ);
  }
  
  // Pre-fill the sound queue for the filter
  for (int i = 0; i < SOUND_QUEUE_LEN; i++) {
    soundQueue[i] = analogRead(soundPin);
    delay(2);
  }

  // --- Start Timer Interrupt ---
  MsTimer2::set(10, checker_ISR);
  MsTimer2::start();
}

// --- MAIN LOOP ---
void loop() {
  handle_button();
  if (isInMenuMode) {
    display_menu();
  } else {
    switch (currentMode) {
      case MODE_LIGHT:      display_light();      break;
      case MODE_SOUND:      display_sound();      break;
      case MODE_TEMP_HUMID: display_temp_humid(); break;
      case MODE_PRESSURE:   display_pressure();   break;
      case MODE_ACCEL:      display_accel();      break;
    }
  }
}

// --- BUTTON HANDLING LOGIC ---
void handle_button() {
  static bool buttonWasPressed = false;
  if (pressCounter > 0) {
    buttonWasPressed = true;
    ledBlinkEnable = true;
    if (pressCounter > LONG_PRESS_CLICKS) {
      isInMenuMode = !isInMenuMode;
      tone(buzzerPin, 800, 150);
      while (digitalRead(buttonPin) == HIGH) {
        delay(10);
      }
      pressCounter = 0;
      buttonWasPressed = false;
    }
  } 
  else if (buttonWasPressed) {
    buttonWasPressed = false;
    if (isInMenuMode) {
      int selected = analogRead(rotaryPin) / 204.8 + 1;
      if (selected >= MODE_LIGHT && selected <= MODE_ACCEL) {
        currentMode = (ProgramMode)selected;
      }
      isInMenuMode = false;
      tone(buzzerPin, 500, 50);
    }
  }
}

// --- DISPLAY FUNCTIONS ---
void display_menu() {
  int n = analogRead(rotaryPin) / 204.8 + 1;
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_ncenB10_tr);
    u8g2.drawStr(18, 12, "SELECT MODE");
    u8g2.drawHLine(0, 16, 128);
    switch (n) {
      case 1: u8g2.drawXBMP(49, 24, 30, 30, light_tmp); u8g2.drawStr(44, 62, "Light"); break;
      case 2: u8g2.drawXBMP(49, 24, 30, 30, sound_bmp1); u8g2.drawStr(44, 62, "Sound"); break;
      case 3: u8g2.drawXBMP(49, 24, 30, 30, temp_bmp1); u8g2.drawStr(20, 62, "Temp/Humid"); break;
      case 4: u8g2.drawXBMP(49, 24, 30, 30, pressure_bmp); u8g2.drawStr(28, 62, "Pressure"); break;
      case 5: u8g2.drawXBMP(49, 24, 30, 30, acel_bmp); u8g2.drawStr(20, 62, "Accelerometer"); break;
    }
  } while (u8g2.nextPage());
}

void display_light() {
  int l = analogRead(lightPin);
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_t0_16b_mr);
    u8g2.drawCircle(8, 8, 8, U8G2_DRAW_ALL);
    if (l >= 50 && l < 100) u8g2.drawDisc(8, 8, 8, U8G2_DRAW_UPPER_LEFT);
    if (l >= 100 && l < 200) u8g2.drawDisc(8, 8, 8, U8G2_DRAW_UPPER_RIGHT | U8G2_DRAW_UPPER_LEFT);
    if (l >= 200 && l < 350) u8g2.drawDisc(8, 8, 8, U8G2_DRAW_LOWER_LEFT | U8G2_DRAW_UPPER_RIGHT | U8G2_DRAW_UPPER_LEFT);
    if (l >= 350) u8g2.drawDisc(8, 8, 8, U8G2_DRAW_ALL);
    u8g2.setCursor(26, 32); u8g2.print(F("Light:"));
    u8g2.setCursor(80, 32); u8g2.print(l);
    u8g2.drawHLine(0, 48, 128);
  } while (u8g2.nextPage());
}

void display_sound() {
  int s = analogRead(soundPin);
  s = filter_sound(s, soundQueue, SOUND_QUEUE_LEN);
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_t0_16b_mr);
    u8g2.drawXBMP(0, 0, 20, 20, sound_bmp);
    u8g2.setCursor(28, 32); u8g2.print(F("Sound:"));
    u8g2.setCursor(80, 32); u8g2.print(s);
  } while (u8g2.nextPage());
}

void display_temp_humid() {
  // The dht.read calls are the same for both DHT11 and DHT20
  float humid = dht.readHumidity();
  float temp = dht.readTemperature();

  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_t0_16b_mr);
    u8g2.drawXBMP(0, 0, 20, 30, temp_bmp);
    u8g2.drawXBMP(0, 35, 20, 20, hum_bmp);
    u8g2.drawLine(25, 0, 25, 64);
    u8g2.setCursor(32, 16); u8g2.print(F("Temp:"));
    u8g2.setCursor(78, 16); u8g2.print(temp, 1);
    u8g2.drawStr(110, 16, "C");
    u8g2.setCursor(32, 48); u8g2.print(F("Humid:"));
    u8g2.setCursor(84, 48); u8g2.print(humid, 0);
    u8g2.drawStr(110, 48, "%");
  } while (u8g2.nextPage());
}

void display_pressure() {
  float pressure = 0;
#if (PRESSURE_SENSOR_TYPE == SENSOR_BME280)
  pressure = bmp280.getPressure(); // Pa
#elif (PRESSURE_SENSOR_TYPE == SENSOR_SPL07)
  if (spl.pressureAvailable()) {
    pressure = spl.readPressure(); // Pa
  }
#endif
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_t0_16b_mr);
    u8g2.drawXBMP(0, 0, 20, 20, pressure_bmp1);
    u8g2.setCursor(20, 37); u8g2.print("Pressure:");
    u8g2.setCursor(25, 51); u8g2.print(pressure / 100.0F, 2);
    u8g2.print(" hPa");
  } while (u8g2.nextPage());
}

void display_accel() {
  float ax = accelerometer.getAccelerationX();
  float ay = -accelerometer.getAccelerationY();
  float az = accelerometer.getAccelerationZ();

  if (ay > 0.2) ball_y -= (ay * 2);
  if (ay < -0.2) ball_y -= (ay * 2);
  if (ax > 0.2) ball_x += (ax * 2);
  if (ax < -0.2) ball_x += (ax * 2);

  ball_x = constrain(ball_x, 54, 106);
  ball_y = constrain(ball_y, 14, 56);

  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_t0_12b_mr);
    u8g2.setCursor(0, 16); u8g2.print(F("X:")); u8g2.print(ax, 2);
    u8g2.setCursor(0, 32); u8g2.print(F("Y:")); u8g2.print(ay, 2);
    u8g2.setCursor(0, 48); u8g2.print(F("Z:")); u8g2.print(az, 2);
    u8g2.drawFrame(50, 10, 60, 50);
    u8g2.drawDisc(ball_x, ball_y, 3, U8G2_DRAW_ALL);
  } while (u8g2.nextPage());
}

// --- UTILITY FUNCTIONS ---
int filter_sound(int newData, int queue[], int len) {
  int max_val = newData;
  int min_val = newData;
  long sum = newData;
  for (int i = len - 1; i > 0; i--) {
    queue[i] = queue[i - 1];
    if (queue[i] > max_val) max_val = queue[i];
    if (queue[i] < min_val) min_val = queue[i];
    sum += queue[i];
  }
  queue[0] = newData;
  if (len > 2) {
    sum = sum - max_val - min_val;
    return sum / (len - 2);
  } else {
    return sum / len;
  }
}
